# -*- coding: utf-8 -*-
from odoo.addons.base.maintenance.migrations import util
from operator import itemgetter


def migrate(cr, version):
    """ Checks the state of the taxes before starting the migration, generating
    the appopriate errors and warnings.
    """

    # Remove child tax relation where amount_type is not group
    # because it's nonsense to have it.
    cr.execute(
        """DELETE FROM account_tax_filiation_rel atr
            USING account_tax at
            WHERE at.id = atr.parent_tax
              AND at.amount_type != 'group'"""
    )

    # Verify that there is no cycle between parent_tax and child_tax
    #
    # Also provide a beautiful display of the error that only show one line by issue.
    # For instance [10,11,12,11] is the same issue as [23,4,12,11,12]
    # because 11 reference 12 and 12 references 11 and so on ...
    # So only show the cycle [11, 12, 11]
    cr.execute(
        """WITH RECURSIVE cycle_(child_tax, parent_tax, depth_, path_, has_cycle) AS
        (
            SELECT child_tax, parent_tax, 0, ARRAY[child_tax], FALSE FROM account_tax_filiation_rel
            UNION
            SELECT cycle_.child_tax, r.parent_tax, depth_+1, path_||r.child_tax, r.child_tax=ANY(path_)
            FROM account_tax_filiation_rel r, cycle_
            WHERE r.child_tax = cycle_.parent_tax
            AND depth_ < 10
            AND has_cycle = false
        )
        SELECT path_ FROM cycle_
        WHERE has_cycle = true """
    )
    if cr.rowcount:
        filtered_cycles = set()
        for line in cr.fetchall():
            # get the index of the first tax that appears twice
            dup_idx = [i for i, n in enumerate(line[0]) if line[0].count(n) == 2][0] + 1
            # truncate the list to only keep the recurrent part
            cycle = line[0][dup_idx:]
            # rewrite the cycle starting from minimum value of the tax
            min_idx = min(enumerate(cycle), key=itemgetter(1))[0]
            cycle = cycle[min_idx:] + cycle[:min_idx] + [cycle[0]]
            filtered_cycles.add(tuple(cycle))
        raise util.MigrationError(
            f"""There exists cycle(s) in parent tax and child tax.
            This is an issue in configuration, please adapat tax configuration and try to upgrade again.
            Tax(es): {filtered_cycles}"""
        )

    # Check that no invoice/credit note with negative quantities on its lines is
    # reconciled with a credit note/invoice and uses cash basis taxes. This case
    # is not supported by the script, and creates and entry in the migration report.
    # This is due to the fact we cannot differenciate automatically (at least, not
    # easily enough) between invoice and refund lines in this case ; so those situations
    # require to be handled manually (it shouldn't happen often).

    cr.execute("""
        SELECT array_agg(caba_move.id)
        FROM account_move caba_move
        JOIN account_partial_reconcile caba_rec ON caba_rec.id = caba_move.tax_cash_basis_rec_id
        JOIN account_move_line caba_source_aml ON caba_source_aml.id IN (caba_rec.debit_move_id, caba_rec.credit_move_id)
        JOIN account_invoice caba_source_invoice ON caba_source_invoice.move_id = caba_source_aml.move_id
        WHERE caba_source_invoice.move_id IN
        (
            -- To detect negative invoice lines with based on payment taxes
            SELECT distinct aml.move_id
            FROM account_move_line aml
            JOIN account_invoice inv ON aml.move_id = inv.move_id
            JOIN account_move_line_account_tax_rel aml_tax_ids ON aml_tax_ids.account_move_line_id = aml.id
            JOIN account_tax tax ON tax.id = aml_tax_ids.account_tax_id
            WHERE (aml.debit > 0 AND inv.type IN ('out_invoice', 'in_refund'))
                  OR (aml.credit > 0 and inv.type IN ('in_invoice', 'out_refund'))
                  AND tax.tax_exigibility = 'on_payment'
        )
        GROUP BY caba_move.id
        HAVING ('in_invoice' = any(array_agg(caba_source_invoice.type)) AND 'in_refund' = any(array_agg(caba_source_invoice.type)))
        OR ('out_invoice' = any(array_agg(caba_source_invoice.type)) AND 'out_refund' = any(array_agg(caba_source_invoice.type)))
    """)
    if cr.rowcount:
        util.add_to_migration_reports(
            """The following cash basis entries have been generated by the matching of an invoice with a credit note, using negative quantities.
            They probably don't have been migrated properly, please contact support for manual investigation.
            account.move ids: %s""" % ','.join(map(str, cr.fetchone()[0])),
            "Cash basis taxes warning")
